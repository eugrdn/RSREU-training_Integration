# Лабораторная работа №3

## Интеграция пользовательского интерфейса с базой данных

В данной лабораторной работе необходимо объединить знания полученные на предыдущих лабах, для выполнения интеграции между клиентом, сервером и БД.

Далее пошагово описан процесс настройки и взаимодействия отдельных модулей, а т.ж приведен список заданий по вариантам в конце документа.

### Шаг :one: -- Подключение MongoDB

Для того, чтобы обеспечить взаимную работу нашей БД с сервером необходимо установить специальный npm-пакет [**mongodb**](https://www.npmjs.com/package/mongodb), который является официальным драйвером [MongoDB](https://www.mongodb.com/) для [Node.js](https://nodejs.org/en/) и предоставляет высокоуровневое API поверх mongodb-ядра. Скорее всего он у вас уже установлен. Для этого загляните в файл package.json (объект "_dependencies_"), если же нет, введите в консоли следующую команду

``` js
  npm install --save mongodb
```

Теперь необходимо подключить установленный пакет к проекту. Для того, чтобы использовать объект нашей БД в любом месте проекта вынесем логику взаимодействия с ним в отдельный модуль: создадим папку `./db` в корне проекта, а т.ж файл `index.js` в ней.

Импортируем нужную нам библиотеку с помощью подхода CommonJS (функции _required_). В данном случае нас интересует объект [MongoClient](https://www.npmjs.com/package/mongodb#connecting-to-mongodb), который позволит установить соединение с БД, а затем при ее успешном установлении получить объект БД. 

Ниже приведен код модуля, который экспортирует метод **connect**, который принимает на вход один парамер -- путь к БД, затем пробует установить соединение, и кладет в переменную _db объект БД, если соединение установлено, в противном случае передает ошибку. Перенесите этот код в свой модуль.

``` js
const MongoClient = require('mongodb').MongoClient;
let _db = null;

module.exports = {
  connect(url) {
    return MongoClient.connect(url)
      .then(db => (_db = db))
      .catch(err => Promise.reject(err));
  },
};
```

>**Важно!** В данном подходе мы используем [_Promise_](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise), чтобы получить результат подключения к БД. 
**Promise** – это специальный объект, который содержит своё состояние, и используется для работы с асинронными вычислениями (похоже на Futures в Java). Для передачи результата от одного обработчика к другому у Promise используется чейнинг _прим._ `...then(...).then(...)`. Этот подход мы будем использовать далее в лаботаторной работе.

Отлично, теперь переменная _db хранит объект базы данных. Но сейчас он не очень полезен, т.к используется только в текущем модуле. Целесообразно будет написать метод, который бы отдавал нам этот объект. 

#### Задание 1.1 
>Напишите метод `getInstance` (по примеру `#connect`), который будет отдавать объект БД, если тот имеется, в противном случае, выбрасываем ошибку, что соединение прервано.

Для удобства добавим т.ж метод `getCollection`, который будет принимать название коллекции БД, и возвращать объект этой коллекции соответственно, в противном случае -- ошибка о не существующей коллекции.

```js
module.exports = {
  ...
  getCollection(name) {
    const collection = this.getInstance().collection(name);
    
    if (!collection) {
      throw Error(`Requested Collection "${name}" not found!`);
    }
    return collection;
  }
}
```

Шаг 1 почти завершен, осталось выполнить само подключение, используя наш модуль db. Перейдем в файл "server.js", подключим наш модуль, а т.ж зададим **URL** нашей БД в константе.

```js
const MongoDB = require('./db');
const DB_URL = 'mongodb://localhost:27017/library';
```

Далее используя написанный ранее метод **connect** установим соединение с БД, если все успешно в следующем .then мы можем использовать серверную часть, в противном случае выводим ошибку соединения и завершаем программу.

```js
// импорт зависимостей
...

MongoDB.connect(DB_URL)
  .then(() => {
    console.log(`Connected succsessfully!`);
    // код серверной части
    ...
  })
  .catch(err => console.log(`An error with connection to db ${err}!`));
```

### Шаг :two: -- Создание сервисов

В предыдущих лабораторных работах вами были созданы несколько путей для доступа к API (`./api/...`). Сейчас они  предоставляют фиктивные данные. Наша задача -- создать модуль, который будет иметь доступ к объекту БД и вытаскивать из нее необходимые данные, согласно запросам с клиента.

Рассмотрим пример с созданием сервиса для коллекции книг.

Создадим папку `./services`, и файл `book.service.js`. 
Получим объект коллекции "books" из нашей БД `./db/index.js` с помощью #getCollection и для удобства запишем его в отдельную переменную. 

```js
const bookCol = require('../db').getCollection('books');
```

Далее создадим объект сервиса, который в дальнейшем будет пополняться методами для работы с БД, а т.ж выполним его `export`. На примере запроса получения всех книг - **GET /api/books** напишем метод, который будем использовать в API:

```js
const service = {
  getBooks() {
    return bookCol.find({}).toArray();
  },
};

module.exports = service;
```

Синтаксис запросов с помощью _mongodb_ очень похож на mongo-shell, используемый вами на предыдущей лабе. Однако, вы могли заметить метод "**toArray**". Дело в том, что метод find возвращает не данные, а объект _Cursor_ - указатель на результирующий набор данных, полученных с помощью запроса. Но нам нужны документы, а не указатель. Для этого и используется метод "toArray".

Подробнее про cursor можно прочитать [здесь](https://docs.mongodb.com/manual/reference/method/js-cursor/), а про метод toArray [здесь](https://docs.mongodb.com/manual/reference/method/cursor.toArray/index.html).


> **Важно!** Драйвер mongodb позволяет использовать 2 вида управления асинхронными операциями:
>* `callback`, передаваемый в используемую функцию
>* возвращая `Promise` из используемой функции
>
>Выполняя запрос к БД мы также выполняем асинхронную операцию. Ранее в этой лекции приводилось описание удобного применения Promise используя _chaining_, далее в примере, мы вызываем **.then()** у метода _getAllBooks_, это значит, что метод _toArray_, нашего запроса, вернул Promise с данными, которые мы как раз удобно получаем в следущем **.then()**. После чего вызываем метод __send__ объекта response, и отправляем данные на клиент.

Далее импортируем наш сервис в файл с API и используем его по-назначению:

```js
...
const bookService = require('../services/book.service');

router
  .get('/books', (req, res) => {
      service.getAllBooks()
        .then(data => res.send(data))
        .catch(err => res.send(err));
  })
  ...
```

Отлично! У нас написан сервис для коллекции книжек. Но это еще не все :grimacing:

На нашем клиенте реализована сортировка и категоризация имеющихся книжек. Список категорий и фильтров мы так же будет передавать с сервера при начальной загрузке нашего клиентского приложения, коллекций _Фильтров_ и _Категорий_ соответственно.

#### 🎭 Задания по вариантам
#### Задание 2.1
>По примеру создания _bookService_, написать сервис для коллекции:
>* "categories" -- четный вариант
>* "filters" -- нечетный вариант
>
>который будут иметь единственный метод `getAll(Categories|Filters)` и подключить его к соответствующим ручкам роутера.

P.S. т.к эти сервисы понадобятся каждому, код сервиса другого варианта можно стащить у соседа :poop:, или написать самому :thumbsup:. 

### Шаг :three: -- Обработка составных запросов. Фильтры
Как вы могли заметить, на нашем клиенте имеется возможность ввести что-либо в стоку поиска, выбрать категорию или фильтр. Чтобы сообщить серверу о таких дополнительных параметрах, клиент в процессе GET-запроса может передавать параметры выполнения в URI ресурса после символа `?`. В нашем случае дополнительными параметрами строки запроса являются:
* `search` -- символы строки поиска
* `activeFilter` -- id выбранного фильтра
* `activeCategory` -- id выбранной категории

Каждый из параметров не обязательно может быть выбран/введен, в этом случае он не отправляется.

Для получения этих параметров запроса в Express.js используется объект запроса функции обработчика `.get('/', (reqest, response) => ...)`, а именно его свойство .query.

>**Важно!** Не путать request.**query** и request.**params**:
>* params 
>
>       GET /api/books/1
>       app.get('/books/:id', (reqest, response)=>...)
>
>       request.params.id // 1
>
> * query
>
>       GET /api/books?search='Figth Club'
>       app.get('/books', (reqest, response)=>...)
>
>       request.query.search // Figth Club

Подробнее о _query_ [здесь](http://expressjs.com/ru/api.html#req.query), о _params_ [тут](http://expressjs.com/ru/api.html#req.params).

На примере, описанного ранее запроса для получения всех книг `GET /api/books`, добавим поддержку выборки с фильтрацией. В нашем случае запрос GET может содержать 3 параметра, т.е для того, чтобы на сервере проверить одно из возможных состояний фильтрации, нам необходимо написать 2^3 проверок (каждый фильтр может быть как в активном состоянии, так и не активен -- не отправляться).
Для исключения написания большого boilerplate на проверку всех условий, реализуем функцию-утилиту, которая будет выполнять для каждой книги проверку на соответствие каждому из фильтров. Если фильтр не указан -- опускаем проверку.

>**Важно!** Параметры категории и фильтра в строке запроса передаются с помощью id-шников. Нам же будет удобнее работать с _типами_, соответствующих объектов, хранящихся в наших коллекциях. Для этого напишем функцию в каждом из сервисов, по получению необходимого объекта по известному id.

#### 🎭 Задания по вариантам
#### Задание 3.1
> Написать метод:
>* `getCategoryById` -- четный вариант
>* `getFilterById` -- нечетный вариант
>
> в categoryService и filterService соответственно.
>
>P.S. (снова) т.к эти методы понадобятся каждому, код метода другого варианта можно стащить у соседа :poop:, или написать самому :thumbsup:. 

Далее запишем импортируем их и используем по назначению:
```js
.get('/books', (req, res) => {
  const {search, activeFilter, activeCategory} = req.query;

  Promise.all([
    filterService.getFilterById(+activeFilter),
    categoryService.getCategoryById(+activeCategory)
  ])
    .then(([filter, category]) => {
        // получаем результат запросов к бд
    })
    .catch(err => res.send(err));
})
```
Здесь мы выполняем 2 асинхронных запроса к БД, и дождавшись ответа от обоих запросов, переходим далее. Подробнее о _Promise.all_ [здесь](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all).

> Обратите внимание на знак "+" рядом с идентификаторами полученных id. Это необходимо для приведения аргумента функции _**get...ById**_ к типу **Number**, т.к схемы `mongodb` объектов чувствительны к типам, и опустив эту операцию мы будем искать id, представленный строковым типом, хотя в наших коллекциях он типа Number.

Вернемся к нашей функции-утилите...

Создадим папку `./utils` в корне проекта и файл `meet-query.utils.js`. Код данного модуля привден ниже.

```js 
function meetQuery({book, search, filter, category}) {
  const expectations = [
    meetSearch(search),
    meetFilter(filter),
    meetCategory(category)
  ];

  return expectations.filter(f => f(book)).length === expectations.length;
}

function meetSearch(queryString) {
  return book =>
    queryString
      ? queryString.includes(book.title) || queryString.includes(book.author)
      : true;
}

function meetFilter(filter) {
  return book => {
    // TODO
  };
}

function meetCategory(category) {
  return book => (category ? book.categories.includes(category.type) : true);
}

module.exports = meetQuery;
```
Здесь, в фукнкции meetQuery, проверяется, удовлетворяет ли объект "book" каждому из фильтров (строке поиска, категориям и фильтрам). Фильтр по строке поиска и категориям уже приведен. Проверку по "фильтрам" необходимо написать Вам самим.

#### Задание 3.2
>Написать функцию проверки объекта книги на соответствие полученному фильтру.

Далее выполним импорт нашей функции в файле `api/index.js`, и в обработчике нашего GET запроса, предварительно получив список всех книг, проверим каждую из них с помощью новой супер-утилиты :rocket::

```js
 bookService
  .getAllBooks()
  .then(data => {
    const requiredBooks = data.filter(book =>
      meetQuery({book, search, filter, category})
    );

    return res.send(requiredBooks);
  })
  .catch(err => res.send(err));
```

>P.S. Данный способ обработки запроса не является оптимальным, поскольку каждый раз мы получать список всех книг. Подумайте как можно было бы его оптимизировать.

Отлично, теперь мы можем фильтровать нашу коллекцию! Практическая часть закончена. Далее приведены самостоятельные задания, которые основаны на пройденном материале.

## Самостоятельные задания
Необходимо написать функцию обработчик POST-запроса `/api/book` в зависимости от типа `action` вашего варианта.

>**Важно!** Дополнительные параметры в POST-запросе передаются в теле запроса (объект **request.body**). Подробнее про POST можно почитать [здесь](https://ru.wikipedia.org/wiki/POST_(HTTP)).

Для каждого варианта указана **схема тела запроса**.

Ответ клиенту подразумевает **обновленный список книг**, удовлетворяющий фильтрам, указанным в теле запроса.

>P.S. Параметр id, который пердается с клиента, представляет собой шестнадцатеричный код, который MongoDB генерирует при создании объета автоматически. Для выбора необходимой книги по такому id необходимо будет импортировать функцию _.ObjectId_ из пакета `mongodb`, и использовать ее как обертку над принятым id, прим. `{"_id": ObjectId(id)}`. Подробнее об [ObjectId](https://docs.mongodb.com/manual/reference/method/ObjectId/).

#### Вариант 1. CREATE
Обработчик запроса на добавление книги (кнопка ADD A BOOK).
```js
// schema
{
  action: 'create',
  search: string | undefined,
  activeFilter: string | undefined,
  activeCategory: string | undefined,
  book: {
    title: string,
    author: string,
    categories: string[],
    img: string
  }
}
```

#### Вариант 2. UPDATE
Обработчик запроса на изменение рейтинга книги (клик на звезды под книгой).
```js
// schema
{
  action: 'update',
  search: string | undefined,
  activeFilter: string | undefined,
  activeCategory: string | undefined,
  id: string,
  rating: number
}
```

#### Вариант 3. DELETE 
Обработчик запроса на удаление книги (клик на крестик, при наведении мыши на книгу).
```js
// schema
{
  action: 'delete',
  search: string | undefined,
  activeFilter: string | undefined,
  activeCategory: string | undefined,
  id: string,
}
```

<p align="center">
  The End.
</p>

<p align="center">
  :tada:
</p>

